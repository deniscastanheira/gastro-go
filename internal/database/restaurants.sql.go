// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: restaurants.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOpeningHour = `-- name: CreateOpeningHour :one
INSERT INTO restaurant_opening_hours (
    restaurant_id, weekday, opens_at, closes_at
) VALUES (
    $1, $2, $3, $4
) RETURNING id, restaurant_id, weekday, opens_at, closes_at, created_at, updated_at
`

type CreateOpeningHourParams struct {
	RestaurantID uuid.UUID `json:"restaurant_id"`
	Weekday      int32     `json:"weekday"`
	OpensAt      int32     `json:"opens_at"`
	ClosesAt     int32     `json:"closes_at"`
}

func (q *Queries) CreateOpeningHour(ctx context.Context, arg CreateOpeningHourParams) (RestaurantOpeningHour, error) {
	row := q.db.QueryRow(ctx, createOpeningHour,
		arg.RestaurantID,
		arg.Weekday,
		arg.OpensAt,
		arg.ClosesAt,
	)
	var i RestaurantOpeningHour
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.Weekday,
		&i.OpensAt,
		&i.ClosesAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPaymentMethod = `-- name: CreatePaymentMethod :one
INSERT INTO restaurant_payment_methods (
    restaurant_id, method
) VALUES (
    $1, $2
) RETURNING id, restaurant_id, method, created_at, updated_at
`

type CreatePaymentMethodParams struct {
	RestaurantID uuid.UUID `json:"restaurant_id"`
	Method       string    `json:"method"`
}

func (q *Queries) CreatePaymentMethod(ctx context.Context, arg CreatePaymentMethodParams) (RestaurantPaymentMethod, error) {
	row := q.db.QueryRow(ctx, createPaymentMethod, arg.RestaurantID, arg.Method)
	var i RestaurantPaymentMethod
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.Method,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRestaurant = `-- name: CreateRestaurant :one
INSERT INTO restaurants (
    name, slug, description, status, category, rating, total_reviews,
    delivery_fee, min_order_value, preparation_time_min,
    supports_pickup, supports_delivery, logo_url, banner_url
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING id, name, slug, description, status, category, rating, total_reviews, delivery_fee, min_order_value, preparation_time_min, supports_pickup, supports_delivery, logo_url, banner_url, created_at, updated_at
`

type CreateRestaurantParams struct {
	Name               string      `json:"name"`
	Slug               string      `json:"slug"`
	Description        pgtype.Text `json:"description"`
	Status             string      `json:"status"`
	Category           pgtype.Text `json:"category"`
	Rating             int32       `json:"rating"`
	TotalReviews       int32       `json:"total_reviews"`
	DeliveryFee        int64       `json:"delivery_fee"`
	MinOrderValue      int64       `json:"min_order_value"`
	PreparationTimeMin int32       `json:"preparation_time_min"`
	SupportsPickup     bool        `json:"supports_pickup"`
	SupportsDelivery   bool        `json:"supports_delivery"`
	LogoUrl            pgtype.Text `json:"logo_url"`
	BannerUrl          pgtype.Text `json:"banner_url"`
}

func (q *Queries) CreateRestaurant(ctx context.Context, arg CreateRestaurantParams) (Restaurant, error) {
	row := q.db.QueryRow(ctx, createRestaurant,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.Status,
		arg.Category,
		arg.Rating,
		arg.TotalReviews,
		arg.DeliveryFee,
		arg.MinOrderValue,
		arg.PreparationTimeMin,
		arg.SupportsPickup,
		arg.SupportsDelivery,
		arg.LogoUrl,
		arg.BannerUrl,
	)
	var i Restaurant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Status,
		&i.Category,
		&i.Rating,
		&i.TotalReviews,
		&i.DeliveryFee,
		&i.MinOrderValue,
		&i.PreparationTimeMin,
		&i.SupportsPickup,
		&i.SupportsDelivery,
		&i.LogoUrl,
		&i.BannerUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRestaurantAddress = `-- name: CreateRestaurantAddress :one
INSERT INTO restaurant_addresses (
    restaurant_id, street, number, complement, city, state, zip_code, lat, lng
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, restaurant_id, street, number, complement, city, state, zip_code, lat, lng, created_at, updated_at
`

type CreateRestaurantAddressParams struct {
	RestaurantID uuid.UUID   `json:"restaurant_id"`
	Street       string      `json:"street"`
	Number       string      `json:"number"`
	Complement   pgtype.Text `json:"complement"`
	City         string      `json:"city"`
	State        string      `json:"state"`
	ZipCode      string      `json:"zip_code"`
	Lat          float64     `json:"lat"`
	Lng          float64     `json:"lng"`
}

func (q *Queries) CreateRestaurantAddress(ctx context.Context, arg CreateRestaurantAddressParams) (RestaurantAddress, error) {
	row := q.db.QueryRow(ctx, createRestaurantAddress,
		arg.RestaurantID,
		arg.Street,
		arg.Number,
		arg.Complement,
		arg.City,
		arg.State,
		arg.ZipCode,
		arg.Lat,
		arg.Lng,
	)
	var i RestaurantAddress
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.Street,
		&i.Number,
		&i.Complement,
		&i.City,
		&i.State,
		&i.ZipCode,
		&i.Lat,
		&i.Lng,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOpeningHoursByRestaurant = `-- name: DeleteOpeningHoursByRestaurant :exec
DELETE FROM restaurant_opening_hours WHERE restaurant_id = $1
`

func (q *Queries) DeleteOpeningHoursByRestaurant(ctx context.Context, restaurantID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOpeningHoursByRestaurant, restaurantID)
	return err
}

const deletePaymentMethodsByRestaurant = `-- name: DeletePaymentMethodsByRestaurant :exec
DELETE FROM restaurant_payment_methods WHERE restaurant_id = $1
`

func (q *Queries) DeletePaymentMethodsByRestaurant(ctx context.Context, restaurantID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePaymentMethodsByRestaurant, restaurantID)
	return err
}

const getOpeningHoursByRestaurant = `-- name: GetOpeningHoursByRestaurant :many
SELECT id, restaurant_id, weekday, opens_at, closes_at, created_at, updated_at FROM restaurant_opening_hours
WHERE restaurant_id = $1
ORDER BY weekday, opens_at
`

func (q *Queries) GetOpeningHoursByRestaurant(ctx context.Context, restaurantID uuid.UUID) ([]RestaurantOpeningHour, error) {
	rows, err := q.db.Query(ctx, getOpeningHoursByRestaurant, restaurantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RestaurantOpeningHour
	for rows.Next() {
		var i RestaurantOpeningHour
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantID,
			&i.Weekday,
			&i.OpensAt,
			&i.ClosesAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentMethodsByRestaurant = `-- name: GetPaymentMethodsByRestaurant :many
SELECT id, restaurant_id, method, created_at, updated_at FROM restaurant_payment_methods
WHERE restaurant_id = $1
ORDER BY method
`

func (q *Queries) GetPaymentMethodsByRestaurant(ctx context.Context, restaurantID uuid.UUID) ([]RestaurantPaymentMethod, error) {
	rows, err := q.db.Query(ctx, getPaymentMethodsByRestaurant, restaurantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RestaurantPaymentMethod
	for rows.Next() {
		var i RestaurantPaymentMethod
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantID,
			&i.Method,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRestaurantAddress = `-- name: GetRestaurantAddress :one
SELECT id, restaurant_id, street, number, complement, city, state, zip_code, lat, lng, created_at, updated_at FROM restaurant_addresses WHERE restaurant_id = $1 LIMIT 1
`

func (q *Queries) GetRestaurantAddress(ctx context.Context, restaurantID uuid.UUID) (RestaurantAddress, error) {
	row := q.db.QueryRow(ctx, getRestaurantAddress, restaurantID)
	var i RestaurantAddress
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.Street,
		&i.Number,
		&i.Complement,
		&i.City,
		&i.State,
		&i.ZipCode,
		&i.Lat,
		&i.Lng,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRestaurantByID = `-- name: GetRestaurantByID :one
SELECT id, name, slug, description, status, category, rating, total_reviews, delivery_fee, min_order_value, preparation_time_min, supports_pickup, supports_delivery, logo_url, banner_url, created_at, updated_at FROM restaurants WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRestaurantByID(ctx context.Context, id uuid.UUID) (Restaurant, error) {
	row := q.db.QueryRow(ctx, getRestaurantByID, id)
	var i Restaurant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Status,
		&i.Category,
		&i.Rating,
		&i.TotalReviews,
		&i.DeliveryFee,
		&i.MinOrderValue,
		&i.PreparationTimeMin,
		&i.SupportsPickup,
		&i.SupportsDelivery,
		&i.LogoUrl,
		&i.BannerUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRestaurantBySlug = `-- name: GetRestaurantBySlug :one
SELECT id, name, slug, description, status, category, rating, total_reviews, delivery_fee, min_order_value, preparation_time_min, supports_pickup, supports_delivery, logo_url, banner_url, created_at, updated_at FROM restaurants WHERE slug = $1 LIMIT 1
`

func (q *Queries) GetRestaurantBySlug(ctx context.Context, slug string) (Restaurant, error) {
	row := q.db.QueryRow(ctx, getRestaurantBySlug, slug)
	var i Restaurant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Status,
		&i.Category,
		&i.Rating,
		&i.TotalReviews,
		&i.DeliveryFee,
		&i.MinOrderValue,
		&i.PreparationTimeMin,
		&i.SupportsPickup,
		&i.SupportsDelivery,
		&i.LogoUrl,
		&i.BannerUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listRestaurants = `-- name: ListRestaurants :many
SELECT id, name, slug, description, status, category, rating, total_reviews, delivery_fee, min_order_value, preparation_time_min, supports_pickup, supports_delivery, logo_url, banner_url, created_at, updated_at FROM restaurants
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListRestaurantsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListRestaurants(ctx context.Context, arg ListRestaurantsParams) ([]Restaurant, error) {
	rows, err := q.db.Query(ctx, listRestaurants, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Restaurant
	for rows.Next() {
		var i Restaurant
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Status,
			&i.Category,
			&i.Rating,
			&i.TotalReviews,
			&i.DeliveryFee,
			&i.MinOrderValue,
			&i.PreparationTimeMin,
			&i.SupportsPickup,
			&i.SupportsDelivery,
			&i.LogoUrl,
			&i.BannerUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRestaurantAddress = `-- name: UpdateRestaurantAddress :one
UPDATE restaurant_addresses
SET street = $2, number = $3, complement = $4, city = $5, state = $6, zip_code = $7, lat = $8, lng = $9, updated_at = NOW()
WHERE restaurant_id = $1
RETURNING id, restaurant_id, street, number, complement, city, state, zip_code, lat, lng, created_at, updated_at
`

type UpdateRestaurantAddressParams struct {
	RestaurantID uuid.UUID   `json:"restaurant_id"`
	Street       string      `json:"street"`
	Number       string      `json:"number"`
	Complement   pgtype.Text `json:"complement"`
	City         string      `json:"city"`
	State        string      `json:"state"`
	ZipCode      string      `json:"zip_code"`
	Lat          float64     `json:"lat"`
	Lng          float64     `json:"lng"`
}

func (q *Queries) UpdateRestaurantAddress(ctx context.Context, arg UpdateRestaurantAddressParams) (RestaurantAddress, error) {
	row := q.db.QueryRow(ctx, updateRestaurantAddress,
		arg.RestaurantID,
		arg.Street,
		arg.Number,
		arg.Complement,
		arg.City,
		arg.State,
		arg.ZipCode,
		arg.Lat,
		arg.Lng,
	)
	var i RestaurantAddress
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.Street,
		&i.Number,
		&i.Complement,
		&i.City,
		&i.State,
		&i.ZipCode,
		&i.Lat,
		&i.Lng,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRestaurantStatus = `-- name: UpdateRestaurantStatus :one
UPDATE restaurants
SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, name, slug, description, status, category, rating, total_reviews, delivery_fee, min_order_value, preparation_time_min, supports_pickup, supports_delivery, logo_url, banner_url, created_at, updated_at
`

type UpdateRestaurantStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateRestaurantStatus(ctx context.Context, arg UpdateRestaurantStatusParams) (Restaurant, error) {
	row := q.db.QueryRow(ctx, updateRestaurantStatus, arg.ID, arg.Status)
	var i Restaurant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Status,
		&i.Category,
		&i.Rating,
		&i.TotalReviews,
		&i.DeliveryFee,
		&i.MinOrderValue,
		&i.PreparationTimeMin,
		&i.SupportsPickup,
		&i.SupportsDelivery,
		&i.LogoUrl,
		&i.BannerUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
